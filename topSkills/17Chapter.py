"""
ИТЕРАТОРЫ, ГЕНЕРАТОРЫ
И КЛАССИЧЕСКИЕ СОПРОГРАММЫ

Итерирование – одна из важнейших операций обработки данных. А если просматривается набор данных,
не помещающийся целиком в память, то нужен способ выполнять ее лениво, т. е. по одному элементу и по запросу. Именно это
и делает Итератор.
    
Начнем с вопроса о том, как встроенная функция iter(…) делает последовательность итерируемой.

Встроенная функция iter выполняет следующие действия.
1 Смотрит, реализует ли объект метод __iter__, и, если да, вызывает его,
чтобы получить итератор.

2.Если метод __iter__ не  реализован, но реализован метод __getitem__, то
Python создает итератор, который пытается извлекать элементы по порядку, начиная с индекса 0.

3.Если и это не получается, то возбуждается исключение – обычно с  сообщением 'C' object is not iterable, где C – класс объекта.

ПОЭТОМУ ЛЮБАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ ЯВЛЯЕТСЯ ИТЕРИРУЕМОЙ

паттерн Итератор встроен в язык Python, поэтому реализовывать его вручную вам никогда не придется.
Любая стандартная коллекция в  Python является итерируемым объектом,
т.  е. предоставляет итератор, который используется для поддержки следующих операций:
*      циклов for;
*      списковых, словарных и множественных включений;
*      распаковки операций присваивания;
*      конструирования экземпляров коллекций.
В этой главе рассматриваются следующие темы:
*      как встроенная функция iter(…) используется интерпретатором для обработки итерируемых объектов;
*      как реализовать классический паттерн Итератор в Python;
*      как можно заменить классический Итератор генераторной функцией
или генераторным выражением;
*      подробное построчное описание работы генераторной функции;
*      использование генераторных функций общего назначения в стандартной библиотеке;
*      использование предложения yield from для комбинирования генераторов;
*      почему генераторы и  классические сопрограммы, несмотря на внешнюю схожесть, по существу сильно различаются и не должны использоваться совместно.
"""

import re
import reprlib

RE_WORD = re.compile(r'\w+')


class SentenceV:
    def __init__(self, text):
        self.text = text
        self.words = RE_WORD.findall(text)

    def __getitem__(self, index):
        return self.words[index]

    def __len__(self):
        return len(self.words)

    def __repr__(self):
        return 'Sentence(%s)' % reprlib.repr(self.text)


"""
КЛАССИЧЕСКИЙ ИНТЕРАТОР . Отметим, что это не идиоматический код на Python, что станет предельно понятно,
когда мы займемся его рефакторингом. Но он проясняет связь между итерируемой коллекцией и объектом-итератором.
"""


class Sentence:
    def __init__(self, text):
        self.text = text
        self.words = RE_WORD.findall(text)

    def __repr__(self):
        return f'Sentence({reprlib.repr(self.text)})'

    def __iter__(self):
        return SentenceIterator(self.words)


class SentenceIterator:

    def __init__(self, words):
        self.words = words
        self.index = 0

    def __next__(self):
        try:
            word = self.words[self.index]
        except IndexError:
            raise StopIteration()
        self.index += 1
        return word

    def __iter__(self):
        return self


"""
Генераторная функция
"""


class SentenceGen:
    def __init__(self, text):
        self.text = text
        self.words = RE_WORD.findall(text)

    def __repr__(self):
        return f'Sentence({reprlib.repr(self.text)})'

    def __iter__(self):
        for word in self.words:
            yield word


"""
Классические Сопрограммы

Генераторы обычно они используются
как итераторы, но могут использоваться и  как сопрограммы. Сопрограмма –
это в действительности генераторная функция, в теле которой имеется ключевое слово yield. 

1 генераторы порождают данные для итерирования;
2 сопрограммы являются потребителями данных;
3 если не хотите, чтобы сорвало крышу, не путайте эти две концепции;
4 сопрограммы не имеют никакого отношения к итерированию;
5 примечание: у  применения yield для порождения значения в  сопрограмме
    есть свои резоны, но с итерированием они не связаны1
"""

"""
ПРИМЕР: СОПРОГРАММА ДЛЯ ВЫЧИСЛЕНИЯ НАКОПИТЕЛЬНОГО
СРЕДНЕГО
"""

from collections.abc import Generator

"""
сопрограммы и  являются привлекательной альтернативой обратным вызовам при асинхронном программировании – 
они сохраняют локальное состояние между активациями.
"""


def averager() -> Generator[float, float, None]:
    total = 0.0
    count = 0.0
    average = 0.0
    while True:
        term = yield average
        total += term
        count += 1
        average = total / count

"""
В этом тесте вызов next(coro_avg) заставляет сопрограмму дойти до yield,
при этом будет отдано начальное значение average. Запустить сопрограмму
можно также, вызвав coro_avg.send(None), – именно так и поступает встроенная
функция next().
"""
coro_avg = averager()
print(next(coro_avg))
"""
В строке coro_avg.send(10) значение отправляется, после чего сопрограмма активируется. Выражение yield отдает значение
10, которое присваивается переменной term
"""
coro_avg.send(10)
coro_avg.send(30)