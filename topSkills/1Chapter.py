"""Говоря о специальных методах, нужно все время помнить, что они предназначены для вызова интерпретатором,
а не вами. Вы пишете не my_object.__len__(), а len(my_object), и если my_object – экземпляр определенного
пользователем класса, то Python вызовет реализованный вами метод экземпляра __len__.


ПОЧЕМУ LEN – НЕ МЕТОД
В разделе «Как используются специальные методы» выше я писал, что функция len(x) работает очень быстро,
если x – объект встроенного типа. Для встроенных объектов интерпретатор CPython вообще не вызывает никаких методов:
длина просто читается из поля C-структуры. Получение количества элементов в коллекции – распространенная операция,
которая должна работать эффективно для таких разных типов, как str, list, memoryview и т. п. Иначе говоря,
len не вызывается как метод,потому что играет особую роль в модели данных Python, равно как и  abs. Но  благодаря
специальному методу __len__ можно заставить функцию len работать и  для пользовательских объектов. Это разумный
компромисс между желанием обеспечить как эффективность встроенных объектов,так и согласованность языка.Вот еще цитата
из «Дзен Python»: «особые случаи не настолько особые, чтобы из-за них нарушать правила».

Благодаря реализации специальных методов пользовательские объекты могут
вести себя как встроенные типы

Например Эмуляция последовательностей
"""
"""
СПЕЦИАЛЬНЫХ МЕТОДОВ (ОПЕРАТОРЫ НЕ ВКЛЮЧЕНЫ)

Представление в виде строк
и байтов                         __repr__, __str__, __format__, __bytes__, __fspath__
Преобразование в число           __bool__, __complex__, __int__, __float__, __hash__, __index__
Эмуляция коллекций               __len__, __getitem__, __setitem__, __delitem__, __contains__
Итерирование                     __iter__, __aiter__, __next__, __anext__, __reversed__
Выполнение объектов, допускающих вызов, или сопрограмм  __call__, __await__
Управление контекстом             __enter__, __exit__, __aenter__, __aexit__
Создание и уничтожение объектов   __new__, __init__, __del__
Сводка специальных методов  43
Категория Имена методов
Управление атрибутами             __getattr__, __getattribute__, __setattr__, __delattr__, __dir__
Дескрипторы атрибутов             __get__, __set__, __delete__, __set_name__
Абстрактные базовые классы        __instancecheck__, __subclasscheck__
Метапрограммирование классов      __prepare__, _init_subclass__, __class_getitem__, __mro_entries__
"""

"""
Имена специальных методов для операторов

Унарные числовые операторы
- + abs() __neg__ __pos__ __abs__
Операторы сравнения < <= == !- > >= __lt__ __le__ __eq__ __ne__ __gt__
__ge__
Арифметические операторы
+ - * / // % @ divmod()
round() ** pow()
__add__ __sub__ __mul__ __truediv__
__floordiv__ __mod__ __matmul__ __
divmod__ __round__ __pow__
Инверсные арифметические операторы
(арифметические операторы с переставленными
операндами)
__radd__ __rsub__ __rmul__ __
rtruediv__ __rfloordiv__ __rmod__
__rmatmul__ __rdivmod__ __rpow__
Арифметические операторы составного присваивания
+= -= *= /= //= %= @=
**=
__iadd__ __isub__ __imul__ __itruediv____ifloordiv__ __imod__ __imatmul__ __ipow__
Поразрядные операторы & | ^ << >> ~ __and__ __or__ __xor__ __lshift__
__rshift__ __invert__
Инверсные поразрядные
операторы
(поразрядные операторы с переставленными
операндами)
__rand__ __ror__ __rxor__ __
rlshift__ __rrshift__
Поразрядные операторы
составного присваивания
&= |= ^= <<= >>= __iand__ __ior__ __ixor__ __ilshift__ __irshift__

"""